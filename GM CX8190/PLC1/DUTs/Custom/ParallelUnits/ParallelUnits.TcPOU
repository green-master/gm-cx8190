<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.6">
  <POU Name="ParallelUnits" Id="{2de2df00-dc30-47a3-820e-7a0728f9500d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ParallelUnits
VAR_INPUT
	EN: BOOL;
	Tags: REFERENCE TO AdsTagsParallelUnits;
	Parameters: REFERENCE TO GreenMasterBaseParameters;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	LocalAmsNumber: LINT;
	RemoteAmsNumber: LINT;
	RemoteOrderToSend: RemoteOrder;
	RemoteStatusData: RemoteStatusData;
	State: ParallelStates;
	NextState: ParallelStates;
	EN_TON: TON;
	SupplyFlowHysteresis: Hysteresis;
	ExtractFlowHysteresis: Hysteresis;
	ModeChangeTON: TON;
	ModeChangeCounter: DINT;
	LastModeChangeCounter: DINT;
	Below, LastBelow: BOOL;
	Week: WORD;
	FirstTime: BOOL;
	HostName: FB_GetHostName;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT FirstTime THEN
	HostName(bExecute := TRUE);
	IF NOT HostName.bBusy THEN	
		// E6
		IF F_ToUCase(HostName.sHostName) = 'STU_E6-LB01' THEN
			Tags.Settings.RemoteAmsId := '10.138.21.151.1.1';
			Tags.Status.isMaster := TRUE;
		END_IF
		IF F_ToUCase(HostName.sHostName) = 'STU_E6-LB02' THEN
			Tags.Settings.RemoteAmsId := '10.138.21.150.1.1';
			Tags.Status.isMaster := FALSE;
		END_IF
		// E1
		IF F_ToUCase(HostName.sHostName) = 'STU_E1-LB01' THEN
			Tags.Settings.RemoteAmsId := '10.138.21.153.1.1';
			Tags.Status.isMaster := TRUE;
		END_IF
		IF F_ToUCase(HostName.sHostName) = 'STU_E1-LB02' THEN
			Tags.Settings.RemoteAmsId := '10.138.21.152.1.1';
			Tags.Status.isMaster := FALSE;
		END_IF
		Tags.Status.isSlave := NOT Tags.Status.isMaster;
		// First time or remote AMS ID changed
		NextState := ParallelStates.Idle;
		EN_TON(IN := FALSE, PT := T#10S);
		FirstTime := TRUE;
	END_IF
END_IF
Week := F_GetWeekOfTheYear(NowDT());
EN_TON(IN := EN, PT := T#10S);
ModeChangeTON(IN := ModeChangeCounter = LastModeChangeCounter, PT := T#5M); 
LastModeChangeCounter := ModeChangeCounter;
SupplyFlowHysteresis(LimitValue := Tags.Settings.StandaloneMaxFlow, Offset := 300);
ExtractFlowHysteresis(LimitValue := Tags.Settings.StandaloneMaxFlow, Offset := 300);
RemoteOrderToSend.ExtractSP := Tags.Settings.PressureExtractSP;
RemoteOrderToSend.SupplySP := Tags.Settings.PressureSupplySP;
IF EN THEN
	RemoteStatusData := ReadFromRemote();
	Tags.Status.SupplyFlow := Parameters.Regulation.SupplyAir.Flow; 
	Tags.Status.ExtractFlow := Parameters.Regulation.ExtractAir.Flow; 
	IF RemoteStatusData.Valid THEN
		TransferToRemote(sNetId := Tags.Settings.RemoteAmsId, Src := RemoteOrderToSend);	
		SupplyFlowHysteresis(EN := TRUE, Value := RemoteStatusData.RemoteStatus.SupplyFlow + Parameters.Regulation.SupplyAir.Flow);
		ExtractFlowHysteresis(EN := TRUE, Value := RemoteStatusData.RemoteStatus.ExtractFlow + Parameters.Regulation.ExtractAir.Flow);
	ELSE
		SupplyFlowHysteresis(EN := TRUE, Value := Parameters.Regulation.SupplyAir.Flow);
		ExtractFlowHysteresis(EN := TRUE, Value := Parameters.Regulation.ExtractAir.Flow);
	END_IF	
ELSE
	SupplyFlowHysteresis(EN := FALSE);
	ExtractFlowHysteresis(EN := FALSE);
	State := ParallelStates.Startup;
	// Tell remote to run standalone
	IF (NOT RemoteStatusData.Valid) OR (RemoteOrderToSend.Mode <> ParallelModes.Standalone) THEN
		RemoteStatusData := ReadFromRemote();
		RemoteOrderToSend.Mode := ParallelModes.Standalone;
		TransferToRemote(sNetId := Tags.Settings.RemoteAmsId, Src := RemoteOrderToSend);	
	END_IF  
END_IF

IF NextState <> State THEN
	// BEFORE STATE	
	CASE NextState OF
		ParallelStates.Idle:
			Tags.Status.Mode := ParallelModes.Idle;
			Parameters.System.Operation.EN := FALSE;
			RemoteOrderToSend.Mode := ParallelModes.Standalone;
		ParallelStates.Startup:
			Parameters.Regulation.SaveDefaults := FALSE;
			Parameters.System.Operation.EN := FALSE;
		ParallelStates.Standalone:
			Tags.Status.Mode := ParallelModes.Standalone;
			Parameters.System.Operation.EN := TRUE;
			Parameters.Regulation.SupplyAir.ControlMode := FanControlTypes.Pressure;
			Parameters.Regulation.ExtractAir.ControlMode := FanControlTypes.Pressure;
			RemoteOrderToSend.Mode := ParallelModes.Idle;
		ParallelStates.Slave:
			Tags.Status.Mode := ParallelModes.Slave;
			Parameters.System.Operation.EN := FALSE;
			Parameters.Regulation.SupplyAir.ControlMode := FanControlTypes.Const;
			Parameters.Regulation.ExtractAir.ControlMode := FanControlTypes.Const;
			RemoteOrderToSend.Mode := ParallelModes.Master;
		ParallelStates.Master:
			Tags.Status.Mode := ParallelModes.Master;		
			Parameters.System.Operation.EN := FALSE;
			Parameters.Regulation.SupplyAir.ControlMode := FanControlTypes.Const;
			Parameters.Regulation.ExtractAir.ControlMode := FanControlTypes.Const;
			RemoteOrderToSend.Mode := ParallelModes.Idle;
	END_CASE
	State := NextState;		
END_IF
// DO STATE	
CASE State OF
	ParallelStates.Idle:
		;
	ParallelStates.Startup:
		;
	ParallelStates.Standalone:
		;
	ParallelStates.Slave:
		Parameters.System.Operation.EN := Tags.Settings.RemoteOrder.Mode > ParallelModes.Idle;		
		IF Tags.Settings.RemoteOrder.Mode = ParallelModes.Standalone THEN
			Parameters.Regulation.SupplyAir.ControlMode := FanControlTypes.Pressure;
			Parameters.Regulation.ExtractAir.ControlMode := FanControlTypes.Pressure;
		ELSIF Tags.Settings.RemoteOrder.Mode = ParallelModes.Slave THEN
			Parameters.Regulation.SupplyAir.ControlMode := FanControlTypes.Const;
			Parameters.Regulation.ExtractAir.ControlMode := FanControlTypes.Const;
			Parameters.Regulation.SupplyAir.Control.SP := Tags.Settings.RemoteOrder.SupplySP;
			Parameters.Regulation.ExtractAir.Control.SP := Tags.Settings.RemoteOrder.ExtractSP;
		END_IF
	ParallelStates.Master:
		IF ModeChangeTON.Q THEN			
			Below := SupplyFlowHysteresis.Below AND ExtractFlowHysteresis.Below; 
			IF Below <> LastBelow THEN
				ModeChangeCounter := ModeChangeCounter + 1;
			END_IF
			LastBelow := Below;
		END_IF
		IF Below THEN
			IF (Week AND 1) = 0 THEN					
				RemoteOrderToSend.Mode := ParallelModes.Idle;
				Parameters.Regulation.SupplyAir.ControlMode := FanControlTypes.Pressure;
				Parameters.Regulation.ExtractAir.ControlMode := FanControlTypes.Pressure;
				Parameters.Regulation.SupplyAir.Control.SP := Tags.Settings.PressureSupplySP;
				Parameters.Regulation.ExtractAir.Control.SP := Tags.Settings.PressureExtractSP;
				Parameters.System.Operation.EN := TRUE;
			ELSE
				RemoteOrderToSend.Mode := ParallelModes.Standalone;
				Parameters.System.Operation.EN := FALSE;
			END_IF
		ELSE
			RemoteOrderToSend.Mode := ParallelModes.Slave;
			Parameters.Regulation.SupplyAir.ControlMode := FanControlTypes.Const;
			Parameters.Regulation.ExtractAir.ControlMode := FanControlTypes.Const;
			Parameters.Regulation.SupplyAir.Control.SP := PidControlSupplyAir();
			Parameters.Regulation.ExtractAir.Control.SP := PidControlExtractAir();
			RemoteOrderToSend.SupplySP := Parameters.Regulation.SupplyAir.Control.SP; 
			RemoteOrderToSend.ExtractSP := Parameters.Regulation.ExtractAir.Control.SP; 
			Parameters.System.Operation.EN := TRUE;
		END_IF 
END_CASE
// TRANSITION TO NEW STATE?	
CASE State OF
	ParallelStates.Idle:
		IF EN_TON.Q THEN
			NextState := ParallelStates.Startup;			
		END_IF
	ParallelStates.Startup:
		IF NOT EN THEN
			NextState := ParallelStates.Idle;
		END_IF
		IF RemoteStatusData.Valid THEN
			IF LocalAmsNumber > RemoteAmsNumber THEN
				NextState := ParallelStates.Master;
			ELSE		
				NextState := ParallelStates.Slave;
			END_IF
		ELSE
			NextState := ParallelStates.Standalone;		
		END_IF
	ParallelStates.Standalone:
		IF NOT EN THEN
			NextState := ParallelStates.Idle;
		END_IF
		IF RemoteStatusData.Valid AND RemoteOrderToSend.Mode = ParallelModes.Slave THEN
			NextState := ParallelStates.Slave;			
		END_IF
		IF NOT RemoteStatusData.Valid THEN
			NextState := ParallelStates.Standalone;			
		END_IF
	ParallelStates.Slave:
		IF NOT EN THEN
			NextState := ParallelStates.Idle;
		END_IF
		IF NOT RemoteStatusData.Valid THEN
			NextState := ParallelStates.Standalone;			
		END_IF
	ParallelStates.Master:
		IF NOT EN THEN
			NextState := ParallelStates.Idle;
		END_IF
END_CASE
IF NextState <> State THEN
	// AFTER STATE	
	CASE State OF
		ParallelStates.Idle:
			;
		ParallelStates.Startup:
			;
		ParallelStates.Standalone:
			;
		ParallelStates.Slave:
			;
		ParallelStates.Master:
			;
	END_CASE
END_IF
]]></ST>
    </Implementation>
    <Method Name="GetAmsNumbers" Id="{8b184dae-b98f-437b-b887-218bcb47a5ae}">
      <Declaration><![CDATA[METHOD GetAmsNumbers : BOOL
VAR_INPUT
END_VAR
VAR_INST
	LocalAddrBytes: AMSNETID;
	RemoteAddrBytes: AMSNETID;	
	FB_GetLocalAmsNetId: FB_GetLocalAmsNetId;
	UsedRemoteAmsId: string := '???';
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Tags.Settings.RemoteAmsId <> UsedRemoteAmsId THEN
	UsedRemoteAmsId := Tags.Settings.RemoteAmsId;
	RemoteAddrBytes := F_ScanAmsNetIds(Tags.Settings.RemoteAmsId);
	FB_GetLocalAmsNetId(bExecute := TRUE, AddrBytes => LocalAddrBytes);
	FB_GetLocalAmsNetId(bExecute := FALSE);
	IF NOT FB_GetLocalAmsNetId.bBusy AND NOT FB_GetLocalAmsNetId.bError THEN			
		LocalAmsNumber := 	
						SHL(TO_LINT(LocalAddrBytes[0]),  40) + 
						SHL(TO_LINT(LocalAddrBytes[1]),  32) + 
						SHL(TO_LINT(LocalAddrBytes[2]),  24) + 
						SHL(TO_LINT(LocalAddrBytes[3]), 16) + 
						SHL(TO_LINT(LocalAddrBytes[4]), 8) + 
						TO_LINT(LocalAddrBytes[5]); 
		RemoteAmsNumber := 	
						SHL(TO_LINT(RemoteAddrBytes[0]),  40) + 
						SHL(TO_LINT(RemoteAddrBytes[1]),  32) + 
						SHL(TO_LINT(RemoteAddrBytes[2]),  24) + 
						SHL(TO_LINT(RemoteAddrBytes[3]), 16) + 
						SHL(TO_LINT(RemoteAddrBytes[4]), 8) + 
						TO_LINT(RemoteAddrBytes[5]); 
	END_IF
	GetAmsNumbers := TRUE;
ELSE 
	GetAmsNumbers := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="PidControlExtractAir" Id="{c8594678-9bf4-440c-8f52-063a516084c6}">
      <Declaration><![CDATA[METHOD PidControlExtractAir : LREAL
VAR_INPUT
END_VAR
VAR_INST
	pid: FB_BasicPID;
	pidOutput: LREAL;
	bReset: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pid(	fSetpointValue := Tags.Settings.PressureExtractSP, 
		fActualValue := Parameters.IO.AIn.F_BP1, 
		bReset := bReset, 
		fCtrlCycleTime := 0.05, 
		fKp := Tags.Settings.Kp, 
		fTn := Tags.Settings.fTn, 
		fTv := Tags.Settings.fTv, 
		fTd := Tags.Settings.fTd, 
		fCtrlOutput => pidOutput);
PidControlExtractAir := LimitValue(50 + pidOutput, 0, 100);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="PidControlSupplyAir" Id="{190391ff-3d8b-4f81-bcde-0da9556bd2b7}">
      <Declaration><![CDATA[METHOD PidControlSupplyAir : LREAL
VAR_INPUT
END_VAR
VAR_INST
	pid: FB_BasicPID;
	pidOutput: LREAL;
	bReset: bool;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pid(	fSetpointValue := Tags.Settings.PressureSupplySP, 
		fActualValue := Parameters.IO.AIn.T_BP1, 
		bReset := bReset, 
		fCtrlCycleTime := 0.05, 
		fKp := Tags.Settings.Kp, 
		fTn := Tags.Settings.fTn, 
		fTv := Tags.Settings.fTv, 
		fTd := Tags.Settings.fTd, 
		fCtrlOutput => pidOutput);
PidControlSupplyAir := LimitValue(50 + pidOutput, 0, 100);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadFromRemote" Id="{c6962458-7669-4f7b-8fb6-3c1284286952}">
      <Declaration><![CDATA[METHOD ReadFromRemote : RemoteStatusData
VAR_INPUT
END_VAR
VAR_INST
	ReadAdsSymbol:FB_ReadAdsSymByName;	
	RemoteStatus: ParallelUnitsStatus;
	ValidTOF: TOF;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT ReadAdsSymbol.bBusy THEN
	ReadAdsSymbol(	bRead		:=	TRUE,
					sNetId		:=	Tags.Settings.RemoteAmsId,
					nPort		:=	851,
					sVarName	:=	'ADS_ParallelUnits.Tags.Status',
					nDestAddr	:=	ADR(RemoteStatus),
					nLen		:=	SIZEOF(RemoteStatus),
					tTimeout	:=	DEFAULT_ADS_TIMEOUT,
					eComMode	:=	eAdsComModeFastCom);
END_IF;
ReadAdsSymbol(bRead := FALSE);
ValidTOF(IN := NOT ReadAdsSymbol.bBusy AND NOT ReadAdsSymbol.bError, PT := T#1S);
ReadFromRemote.Valid := ValidTOF.Q;
ReadFromRemote.RemoteStatus := RemoteStatus;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="TransferToRemote" Id="{60cfede9-10bb-4159-93d4-39b9dec23d1c}">
      <Declaration><![CDATA[METHOD TransferToRemote : BOOL
VAR_INPUT
	sNetId: T_AmsNetID;
	Src: REFERENCE TO RemoteOrder;
END_VAR
VAR_INST
	WriteAdsSymbol: FB_WriteAdsSymByName;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT WriteAdsSymbol.bBusy THEN
	WriteAdsSymbol(	bWrite		:=	TRUE,
					sNetId		:=	Tags.Settings.RemoteAmsId,
					nPort		:=	851,
					sVarName	:=	'ADS_ParallelUnits.Tags.Settings.RemoteOrder',
					nSrcAddr	:=	ADR(Src),
					nLen		:=	SIZEOF(Src),
					tTimeout	:=	DEFAULT_ADS_TIMEOUT,
					eComMode	:=	eAdsComModeFastCom);
END_IF;
WriteAdsSymbol(bWrite := FALSE);
TransferToRemote := NOT WriteAdsSymbol.bBusy AND NOT WriteAdsSymbol.bError;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>